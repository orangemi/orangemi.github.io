(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{212:function(r,t,e){"use strict";e.r(t);var a=e(2),s=Object(a.a)({},function(){var r=this,t=r.$createElement,e=r._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("h1",{attrs:{id:"cqrs研究"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cqrs研究","aria-hidden":"true"}},[r._v("#")]),r._v(" CQRS研究")]),r._v(" "),e("h1",{attrs:{id:"cqrs-架构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cqrs-架构","aria-hidden":"true"}},[r._v("#")]),r._v(" CQRS 架构")]),r._v(" "),e("p",[r._v("Source: https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/cqrs")]),r._v(" "),e("h2",{attrs:{id:"summary"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#summary","aria-hidden":"true"}},[r._v("#")]),r._v(" Summary")]),r._v(" "),e("p",[r._v("Command and Query Responsibility Segregation(CQRS)是一个将读和写操作分离的架构。")]),r._v(" "),e("p",[e("img",{attrs:{src:"https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/images/cqrs-logical.svg",alt:"image"}})]),r._v(" "),e("p",[r._v("在传统架构中，在同一个数据层面中进行查询和写入操作，对于普通的CRUD操作来说工作的还不错。然而，在复杂应用中，有些情景会变得很奇怪。例如在查询方面，应用会面对不同的查询语句，放回数据时需要将数据根据不同形态转换为对象，对象映射将变得复杂；在更新操作方面，数据写入时会有非常复杂的验证和业务逻辑。最终，数据模型层面会因为携带过多业务显得非常复杂。")]),r._v(" "),e("p",[r._v("还有一个潜在的问题，很多时候查询和写入的负载有着不同的比例，经常有着非常不同的扩张策略。")]),r._v(" "),e("p",[r._v("CQRS旨在利用分离读写模型解决上面所说的问题。使用命令(Command)写入数据，使用查询(Query)读取数据。")]),r._v(" "),e("ul",[e("li",[r._v("命令应该是基于业务的，不应该基于数据的（例如，“预定酒店房间”而不是“将预约状态修改”）。命令可以使用一个异步队列处理的，而不是同步处理的")]),r._v(" "),e("li",[r._v("查询不应修改数据库，一个查询返回的数据不应该封装任何领域信息")])]),r._v(" "),e("p",[r._v("更严谨完备的隔离读写操作，你应该将读写数据库从物理层分离。这样，数据结构可以为查询操作独立优化，例如，读取数据库可以存储一些冗余数据的视图模型(materialized view)，来避免在读取时使用复杂join或者关系模型。甚至可以使用另外一个类型数据库，例如，可以使用关系型数据库写入，而使用文档型数据库读取。")]),r._v(" "),e("p",[r._v("使用不同的读写数据库，数据库之间的数据应该始终保持一致。通常在写任何数据的同时发出一个更新事件(event)来保持同步，写操作和事件应该在同一事务中发生。")]),r._v(" "),e("p",[r._v("有些CQRS实现模型中使用“数据总线”("),e("a",{attrs:{href:"https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing",target:"_blank",rel:"noopener noreferrer"}},[r._v("Event Source pattern"),e("OutboundLink")],1),r._v(")，有了数据总线，应用数据状态可以由保存的一组事件序列来表示。 每一个事件都代表着数据的一组变化。数据的当前状态可以重放(replay)事件得到。在CQRS架构中，利用数据总线可以得到更多的好处，例如同一组的事件可以用于通知系统，用于通知其他组建，这里我们用于通知读取模型。读取模型实际上是利用事件序列来创建出一个数据当前状态的快照，可以使得查询更加有效。然而事件模型使得这个架构变得复杂。")]),r._v(" "),e("p",[e("img",{attrs:{src:"https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/images/cqrs-events.svg",alt:"image"}})]),r._v(" "),e("h2",{attrs:{id:"何时使用cqrs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#何时使用cqrs","aria-hidden":"true"}},[r._v("#")]),r._v(" 何时使用CQRS")]),r._v(" "),e("p",[r._v("在协作领域中，当很多用户需要访问同一份数据，特别是当他们的查询场景和负载情况非常不同的时候，CQRS效果非常显著。")]),r._v(" "),e("p",[r._v("CQRS不是在整个架构中处于顶级，在那些读写结果需要明显差异的子系统中实现CQRS，而其他情况可能会造成多余的复杂度，且没有好处。")]),r._v(" "),e("h2",{attrs:{id:"好处"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#好处","aria-hidden":"true"}},[r._v("#")]),r._v(" 好处")]),r._v(" "),e("ul",[e("li",[r._v("独立扩张：CQRS读写负载和模型完全独立，更少的产生锁问题")]),r._v(" "),e("li",[r._v("优化数据结构：读模型中，可以优化查询，而写模型中，可以优化写入")]),r._v(" "),e("li",[r._v("安全：在写入数据时更容易控制，只有在正确的领域实体中才能写入数据")]),r._v(" "),e("li",[r._v("分离模型的优势：分离读写模型将变得可维护和可扩展。大部分复杂逻辑将应用在写模型上，读取模型变得相对简单")]),r._v(" "),e("li",[r._v("查询简单：由于使用了视图模型，应用可以在查询时避免使用join")])]),r._v(" "),e("h2",{attrs:{id:"挑战"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#挑战","aria-hidden":"true"}},[r._v("#")]),r._v(" 挑战")]),r._v(" "),e("ul",[e("li",[r._v("实现复杂度：CQRS的概念是简单的，但这将带来一个复杂的应用架构，当他还包含数据总线")]),r._v(" "),e("li",[r._v("消息队列：虽然CQRS不需要消息队列，但通常使用消息队列来处理写入数据和发送事件，如果是这样，应用本身需要处理写入失败或者重复写入或者丢失的情况。")]),r._v(" "),e("li",[r._v("最终一致性：如果使用读写分离模型，数据读取可能会脏的或旧的")])]),r._v(" "),e("h2",{attrs:{id:"最佳实践"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#最佳实践","aria-hidden":"true"}},[r._v("#")]),r._v(" 最佳实践")]),r._v(" "),e("ul",[e("li",[r._v("详见"),e("a",{attrs:{href:"https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs",target:"_blank",rel:"noopener noreferrer"}},[r._v("CQRS Pattern"),e("OutboundLink")],1)]),r._v(" "),e("li",[r._v("数据总线来帮你避免更新中的冲突")]),r._v(" "),e("li",[r._v("视图模型帮助你优化查询")])]),r._v(" "),e("h2",{attrs:{id:"微服务中的cqrs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#微服务中的cqrs","aria-hidden":"true"}},[r._v("#")]),r._v(" 微服务中的CQRS")]),r._v(" "),e("p",[r._v("CQRS在微服务架构中非常有优势，其中微服务架构一个重要特性就是：一个服务不能直接访问另外一个服务的数据（译者理解为领域数据）\n"),e("img",{attrs:{src:"https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/images/cqrs-microservices-wrong.png",alt:"image"}})]),r._v(" "),e("p",[r._v("在接下来的图，服务A写入数据，服务B保持同步视图模型，服务A在写入数据的同时发布事件，服务B消费这个事件\n"),e("img",{attrs:{src:"https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/images/cqrs-microservices-right.png",alt:"image"}})])])},[],!1,null,null,null);t.default=s.exports}}]);