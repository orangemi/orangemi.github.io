<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>VuePress</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/assets/css/0.styles.87386866.css" as="style"><link rel="preload" href="/assets/js/app.9057a45e.js" as="script"><link rel="preload" href="/assets/js/2.8149e9c9.js" as="script"><link rel="preload" href="/assets/js/8.ac833798.js" as="script"><link rel="prefetch" href="/assets/js/10.16c00290.js"><link rel="prefetch" href="/assets/js/11.5d2a6e9f.js"><link rel="prefetch" href="/assets/js/3.e26b2b52.js"><link rel="prefetch" href="/assets/js/4.8b9778bd.js"><link rel="prefetch" href="/assets/js/5.f6ed543a.js"><link rel="prefetch" href="/assets/js/6.decf63af.js"><link rel="prefetch" href="/assets/js/7.7ed49bf8.js"><link rel="prefetch" href="/assets/js/9.c5b2df4d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.87386866.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="content default"><h1 id="正确姿势使用gitlab-ci"><a href="#正确姿势使用gitlab-ci" aria-hidden="true" class="header-anchor">#</a> 正确姿势使用Gitlab CI</h1> <h2 id="前言"><a href="#前言" aria-hidden="true" class="header-anchor">#</a> 前言</h2> <p><code>Gitlab CI</code> 是一个好工具，Teambition大多数项目的自动构建和部署开发环境都会使用。但我们在使用上有很多<code>安全</code>问题</p> <h2 id="我们的问题"><a href="#我们的问题" aria-hidden="true" class="header-anchor">#</a> 我们的问题</h2> <ol><li><p>Teambition构建的时候需要安装依赖，在安装依赖的时候需要对应的权限，创建了一个超级image，赋予了gitlab的最高读取权限，可以读取任意repo。这样造成的问题是repo泄漏，当我们招募了一个实习生同学，虽然管理员只赋予了该同学某一个repo的权限，以及CI权限时，与此同时，也泄漏了整个gitlab的代码库。</p></li> <li><p>Teambition后端项目都是基于docker标准化镜像，在构建过程中需要使用docker命令构建镜像以及发布镜像，而runner本身也是一个docker运行时，这样就是一个docker-in-docker的环境。Teambition在runner运行时将<code>宿主机</code>的docker sock 挂载到runner内部，而runner内部只需要有docker-cli就可以运行docker命令了。虽然方便，但泄漏了宿主机的docker，runner在执行中可能对宿主机造成攻击甚至是删除宿主机数据。</p></li> <li><p>Teambition和大多数互联网公司一样，有一支自己的运维团队，所有发布和线上环境的操作都是运维操作的（或运维工具），开发同学在构建好镜像后需要触发运维的部署脚本才能发布。Gitlab CI 也有CI/CD的能力，为什么不使用呢？到底哪里阻碍了DevOps的发展？</p></li></ol> <h2 id="那应该怎么使用gitlab-ci工具呢"><a href="#那应该怎么使用gitlab-ci工具呢" aria-hidden="true" class="header-anchor">#</a> 那应该怎么使用Gitlab CI工具呢</h2> <h3 id="解决依赖安装及权限范围"><a href="#解决依赖安装及权限范围" aria-hidden="true" class="header-anchor">#</a> 解决依赖安装及权限范围</h3> <p>解决依赖安装，这个话题在gitlab-ce的issue列表中存在时间也<a href="https://gitlab.com/gitlab-org/gitlab-ce/issues/18994" target="_blank" rel="noopener noreferrer">非常的久远<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，至今有2,3年了，也经历了<a href="https://docs.gitlab.com/ee/user/project/new_ci_build_permissions_model.html" target="_blank" rel="noopener noreferrer">重大重构<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。目前官方的方案就是利用<code>CI_JOB_TOKEN</code>。我们从头整理需求，这里的需要解决的场景有：</p> <ul><li>开发同学需要在本地开发</li> <li>开发同学需要在本地构建</li> <li>CI需要在CI环境运行测试</li> <li>CI需要在CI环境构建</li> <li>开发同学不能通过CI工具越权</li></ul> <p>我们再看看<code>CI_JOB_TOKEN</code>在CI中的能力吧，我觉得在gitlab的文档没有特别指出这个token的用法和权限范围。我来来回回阅读了好几遍算是理解了，最后经过实际验证得到结论：<code>CI_JOB_TOKEN</code>的权限范围就是用户的权限范围，两者是等价的。除了这个特性，<code>CI_JOB_TOKEN</code>还有几个特征可以利用：</p> <ul><li>只在构建过程中有效，从构建开始到构建结束。</li> <li>在构建过程中不可见，不可打印在日志中。</li> <li>如果是某个用户触发导致构建，CI_JOB_TOKEN是触发用户的权限范围。</li> <li>如果是定时任务schedule或API触发trigger，CI_JOB_TOKEN以那trigger的主人视权限范围</li> <li>CI_JOB_TOKEN亦可用于gitlab docker registry</li> <li>CI_JOB_TOKEN等价于用户private access token (repo only)</li></ul> <p>总的来说CI_JOB_TOKEN能够满足上面提到的场景。那应该如何做呢？</p> <h3 id="本地运行时私有依赖"><a href="#本地运行时私有依赖" aria-hidden="true" class="header-anchor">#</a> 本地运行时私有依赖</h3> <p>我们就拿nodejs项目来说吧。假如我们有给nodejs项目引用了一个私有仓库private-node-lib，通常通过<code>npm install --save git+ssh://git@gitlab-host/private-group/private-node-lib.git#v0.3.0</code>，最终该项目的package.json片段如下：</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;demo-repo&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;version&quot;</span><span class="token operator">:</span> <span class="token string">&quot;1.0.0&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;dependencies&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;@tb/private-library&quot;</span><span class="token operator">:</span> <span class="token string">&quot;git+ssh://git@gitlab-host/private-group/private-node-lib.git#v0.3.0&quot;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对于新接触这个项目的开发人员在本地开发时，使用<code>npm install</code>时，<code>git</code>会使用用户gitlab的git登录身份验证是否有权限，这一点原来也是OK的，如果实习生拥有demo-repo的权限，却没有依赖库的权限，将不能调试开发demo-repo项目，这是理想中的。No problem for local development!</p> <h3 id="本地构建镜像的私有依赖"><a href="#本地构建镜像的私有依赖" aria-hidden="true" class="header-anchor">#</a> 本地构建镜像的私有依赖</h3> <p>开发人员需要构建镜像时会有问题，一般我们的<code>Dockerfile</code>如下结构：</p> <div class="language-Dockerfile extra-class"><pre class="language-text"><code>FROM node:10.15.3-alpine as dependency
RUN apk --no-cache add git

WORKDIR /app
COPY package* /app/

RUN npm install --production

# ready for production
FROM node:10.15.3-alpine

WORKDIR /app
COPY --from=dependency /app/node_modules /app/node_modules
COPY .  /app/

EXPOSE 80 443
CMD [ &quot;npm&quot;, &quot;start&quot; ]
</code></pre></div><p>如果同学不理解分步构建docker镜像的，请移步https://docs.docker.com/develop/develop-images/multistage-build ，或等下回详细介绍分步构建Docker镜像。</p> <p>在本地开发环境，这个Dockerfile的构建将会失败，它的问题在于<code>RUN npm install</code>这一步，由于在镜像内执行<code>npm install</code>失去了宿主机上任何信息，包含已经登录过gitlab的ssh身份信息。那应该如何解决呢？</p> <p>神奇的地方出现了，我们可以通过<code>git config</code>命令替换<code>remote-url</code>的方式获取权限，这一步需要用<code>private access token</code>来代替自己的ssh私钥获取相应的repo权限。具体方法如下：</p> <p>首先，我们要在gitlab中生成一个<code>private access token</code>，具体方法参考：https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html ，这里稍稍翻译一下，在gitlab中右上角个人setting页面中找到access_token，然后生成一个read_repositry权限的access_token，并设置环境变量中<code>export CI_JOB_TOKEN=xxxx</code>，可以在你的<code>~/.bashrc</code>中添加这一行。</p> <p>第二，在Dockerfile 中在<code>npm install</code>之前一步git config的替换</p> <div class="language- extra-class"><pre class="language-text"><code>RUN git config --global url.&quot;https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab-host/&quot;.insteadOf &quot;git://gitlab-host:&quot; \
  &amp;&amp; npm install
</code></pre></div><p>第三，在执行构建镜像时，将环境变量因素加入到构建过程中（可以不填写具体的值）</p> <div class="language- extra-class"><pre class="language-text"><code>docker build -t some_repo --build-arg CI_JOB_TOKEN .
</code></pre></div><p>第四，虽然在命令行中指定了build_arg，但还需要在dockerfile 中确认使用arg参数</p> <div class="language-Dockerfile extra-class"><pre class="language-text"><code>FROM node:10.15.3-alpine as dependency
RUN apk --no-cache add git
ARG CI_JOB_TOKEN
...
</code></pre></div><p>完成上面这些步骤后，可以解决在本地环境中的构建问题，有同学会觉得会有些麻烦，因为感觉只需要自己的ssh私钥加入构建过程中就能解决，是的，但我们还要同时解决CI构建时的问题，个人ssh不能用于CI构建，下面我们来解决一下CI环境下运行和构建问题。</p> <h3 id="ci环境中使用docker命令行"><a href="#ci环境中使用docker命令行" aria-hidden="true" class="header-anchor">#</a> CI环境中使用docker命令行</h3> <p>在讨论gitlab构建镜像前，首先要在CI环境中执行docker命令，而runner本身运行在docker中，这样就形成<code>docker-in-docker</code>的环境，根据<a href="https://docs.gitlab.com/ee/ci/docker/using_docker_build.html" target="_blank" rel="noopener noreferrer">Gitlab官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>指导， 构建docker是最好不要使用宿主机上的docker.sock文件，因为这会泄漏宿主机的root权限，可能会有严重的安全隐患。官方推荐使用docker service作为依赖创建出一个纯净并隔离的环境。最基础的ci配置如下：</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">build-image</span><span class="token punctuation">:</span>
  <span class="token key atrule">stage</span><span class="token punctuation">:</span> build<span class="token punctuation">-</span>image
  <span class="token key atrule">image</span><span class="token punctuation">:</span> docker<span class="token punctuation">:</span>stable <span class="token comment"># 只用docker官方镜像作为基础镜像，拥有docker命令行</span>
  <span class="token key atrule">services</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> docker<span class="token punctuation">:</span>dind <span class="token comment"># 使用docker:dind作为依赖service，提供2375的tcp端口</span>
      <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;--insecure-registry=private-docker-registry-host&quot;</span><span class="token punctuation">]</span>
  <span class="token key atrule">variables</span><span class="token punctuation">:</span>
    <span class="token key atrule">DOCKER_HOST</span><span class="token punctuation">:</span> tcp<span class="token punctuation">:</span>//docker<span class="token punctuation">:</span><span class="token number">2375 </span><span class="token comment"># 默认使用tcp来链接docker-machine</span>
    <span class="token key atrule">DOCKER_DRIVER</span><span class="token punctuation">:</span> overlay2 <span class="token comment"># 优化docker-machine文件系统的优化</span>
  <span class="token key atrule">before_script</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> docker info
    <span class="token punctuation">-</span> docker login <span class="token punctuation">-</span>u <span class="token punctuation">{</span>DOCKER_USER<span class="token punctuation">}</span> <span class="token punctuation">-</span>p $<span class="token punctuation">{</span>DOCKER_PASSWORD<span class="token punctuation">}</span> <span class="token punctuation">{</span>private<span class="token punctuation">-</span>docker<span class="token punctuation">-</span>registry<span class="token punctuation">-</span>host<span class="token punctuation">}</span>
  <span class="token key atrule">script</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> docker build <span class="token punctuation">-</span>t .

</code></pre></div><p>虽然在官方指导中，这个方式需要在注册runner时添加<code>--docker-privileged</code>参数，这个参数仍然会造成安全隐患，但目前只能期待docker官方想办法解决。</p> <p>上述yaml中使用到了<code>docker:dind</code>这个镜像，这个镜像和原生<code>docker:stable</code>镜像没有功能上的差异，只是默认打开了tcp远程端口，如果在主机上长期开放tcp端口势必会带来安全隐患，现在只是在CI生命周期中开放，且外网无法联通，没有太大问题。</p> <p>另外上述yaml中还用到了一个私有docker registry镜像地址，为的是方便推拉私有镜像，这里作者没有研究gitlab的docker registry的注册方法，认为他们是独立的2个服务。</p> <h3 id="ci环境中使用构建docker镜像"><a href="#ci环境中使用构建docker镜像" aria-hidden="true" class="header-anchor">#</a> CI环境中使用构建docker镜像</h3> <p>有了上面2步的准备工作，已经可以在CI环境中正常使用<code>docker build</code>命令了</p> <h2 id="总结"><a href="#总结" aria-hidden="true" class="header-anchor">#</a> 总结</h2> <p>感觉写的已经有点长了，还有如何在CI中利用<code>docker cache</code>的问题还没有解决，这方面知识确实比较零散，无法简单的用一两句话说完。</p> <p>PS. 这里好像忘了提devOps的问题，是的，这个问题更离散，还需读者拥有k8s或运维领域的相关知识。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.9057a45e.js" defer></script><script src="/assets/js/2.8149e9c9.js" defer></script><script src="/assets/js/8.ac833798.js" defer></script>
  </body>
</html>
